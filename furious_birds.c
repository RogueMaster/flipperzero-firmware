#include <gui/icon_i.h>
#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <furi_hal.h>
#include <stdlib.h>
#include <gui/view_dispatcher.h>

/* generated by fbt from .png files in images folder */
#include <furious_birds_icons.h>

#define PIG_COUNT   10
#define ANGLE_START 15

#define RED_START_X  9
#define RED_CENTER_X 7
#define RED_CENTER_Y 8

#define SLINGSHOT_X        24
#define SLINGSHOT_CENTER_X 4
#define SLINGSHOT_Y        35

#define RED_TO_SLINGSHOT_X (SLINGSHOT_X - RED_START_X)

#define ANGLE_MAX 45
#define ANGLE_MIN -45

#define PIG_CENTER_X 6
#define PIG_CENTER_Y 6

#define PIGS_AREA_X_START 50
#define PIGS_AREA_X_END   120
#define PIGS_AREA_Y_START 8
#define PIGS_AREA_Y_END   56

#define MIN_DISTANCE_BETWEEN_PIGS 14

#define AIMING_LINE_LENGTH 20

enum GameState {
    GameStateAiming,
    GameStateFlying,
};

typedef struct {
    uint8_t x;
    uint8_t y;
    bool visible;
} Pig;

typedef struct {
    uint8_t x;
    uint8_t y;
    double y_float;
} Red;

typedef struct {
    Red* red;
    Pig* pigs[PIG_COUNT];
    int8_t angle;
    double_t angle_radians;
    uint8_t state;
    double_t diff;
    int8_t diff_int;
} AppModel;

typedef struct {
    Gui* gui;
    ViewDispatcher* view_dispatcher;
    View* view;
    FuriThread* worker_thread;
    FuriTimer* timer;
    AppModel* model;
    FuriMutex* mutex;
} App;

typedef enum {
    WorkerEventReserved = (1 << 0),
    WorkerEventStop = (1 << 1),
    WorkerEventTick = (1 << 2),
} WorkerEventFlags;

#define WORKER_EVENTS_MASK (WorkerEventStop | WorkerEventTick)

void draw_red(Canvas* canvas, AppModel* model) {
    canvas_draw_icon(canvas, model->red->x - RED_CENTER_X, model->red->y - RED_CENTER_Y, &I_Red);
    // canvas_draw_dot(canvas, state->red->x, state->red->y);
}

void draw_slingshot(Canvas* canvas) {
    canvas_draw_icon(canvas, SLINGSHOT_X - SLINGSHOT_CENTER_X, SLINGSHOT_Y, &I_Slingshot);
    // canvas_draw_dot(canvas, SLINGSHOT_X, SLINGSHOT_Y);
}

void draw_debug_info(Canvas* canvas, AppModel* model) {
    FuriString* xstr = furi_string_alloc();
    furi_string_printf(xstr, "red y_float: %f", model->red->y_float);
    canvas_draw_str(canvas, 0, 8, furi_string_get_cstr(xstr));
    furi_string_printf(xstr, "red y: %d", model->red->y);
    canvas_draw_str(canvas, 0, 16, furi_string_get_cstr(xstr));
    furi_string_printf(xstr, "angle: %d", model->angle);
    canvas_draw_str(canvas, 0, 24, furi_string_get_cstr(xstr));
    furi_string_free(xstr);
}

void draw_pigs(Canvas* canvas, AppModel* model) {
    for(uint8_t i = 0; i < PIG_COUNT; i++) {
        Pig* pig = model->pigs[i];
        if(pig->visible) {
            canvas_draw_icon(canvas, pig->x - PIG_CENTER_X, pig->y - PIG_CENTER_Y, &I_Pig);
            // canvas_draw_dot(canvas, pig->x, pig->y);
        }
    }
}

double_t degree_to_radian(int8_t degree) {
    return ((double_t)degree) / 180 * ((double_t)M_PI);
}

uint8_t calculate_red_start_y(AppModel* model) {
    model->diff = tan(model->angle_radians);
    model->diff_int = RED_TO_SLINGSHOT_X * model->diff;
    return SLINGSHOT_Y + model->diff_int;
}

void recalculate_start_position(AppModel* model) {
    model->angle_radians = degree_to_radian(model->angle);
    model->red->y = calculate_red_start_y(model);
    model->red->y_float = model->red->y;
}

void draw_aiming_line(Canvas* canvas, AppModel* model) {
    if(model->state == GameStateAiming) {
        uint8_t x = AIMING_LINE_LENGTH * cos(model->angle_radians);
        int8_t y = AIMING_LINE_LENGTH * sin(model->angle_radians);
        canvas_draw_line(canvas, SLINGSHOT_X, SLINGSHOT_Y, SLINGSHOT_X + x, SLINGSHOT_Y - y);
    }
}

static void game_draw_callback(Canvas* canvas, void* _model) {
    AppModel* model = (AppModel*)_model;
    canvas_clear(canvas);
    canvas_set_color(canvas, ColorBlack);

    draw_slingshot(canvas);
    draw_aiming_line(canvas, model);
    draw_pigs(canvas, model);
    draw_debug_info(canvas, model);
    draw_red(canvas, model);
}

static bool game_input_callback(InputEvent* event, void* ctx) {
    App* app = ctx;
    furi_assert(app);
    AppModel* model = app->model;

    if(model->state == GameStateFlying) {
        if(event->type == InputTypeShort && event->key == InputKeyBack) {
            model->state = GameStateAiming;
            model->red->x = RED_START_X;
            model->red->y = calculate_red_start_y(model);
            model->red->y_float = model->red->y;
            return true;
        }
    } else if(model->state == GameStateAiming) {
        if(event->type == InputTypeShort || event->type == InputTypeRepeat) {
            if(event->key == InputKeyUp && model->angle > -45) {
                model->angle--;
                recalculate_start_position(model);
                return true;
            } else if(event->key == InputKeyDown && model->angle < 45) {
                model->angle++;
                recalculate_start_position(model);
                return true;
            } else if(event->key == InputKeyOk) {
                model->state = GameStateFlying;
                return true;
            } else if(event->key == InputKeyBack) {
                view_dispatcher_stop(app->view_dispatcher);
                return true;
            }
        }
    }

    return false;
}

uint8_t distance_between(Pig* pig1, Pig* pig2) {
    return sqrt(
        (pig2->x - pig1->x) * (pig2->x - pig1->x) + (pig2->y - pig1->y) * (pig2->y - pig1->y));
}

Pig* create_random_pig(uint8_t i, Pig* pigs[]) {
    Pig* pig = malloc(sizeof(Pig));
    pig->visible = true;

    bool intercept = false;
    do {
        pig->x =
            (furi_hal_random_get() % (PIGS_AREA_X_END - PIGS_AREA_X_START)) + PIGS_AREA_X_START;
        pig->y =
            (furi_hal_random_get() % (PIGS_AREA_Y_END - PIGS_AREA_Y_START)) + PIGS_AREA_Y_START;

        intercept = false;
        for(uint8_t j = 0; j < i; j++) {
            if(distance_between(pigs[j], pig) < MIN_DISTANCE_BETWEEN_PIGS) {
                intercept = true;
                break;
            }
        }
    } while(intercept);

    return pig;
}

static int32_t furious_birds_worker(void* context) {
    furi_assert(context);
    App* app = context;
    UNUSED(app);

    while(1) {
        uint32_t events =
            furi_thread_flags_wait(WORKER_EVENTS_MASK, FuriFlagWaitAny, FuriWaitForever);
        furi_check((events & FuriFlagError) == 0);

        if(events & WorkerEventStop) break;
        if(events & WorkerEventTick) {
            with_view_model(
                app->view,
                AppModel * model,
                {
                    if(model->state == GameStateFlying) {
                        model->red->x++;
                        model->red->y_float = model->red->y_float - sin(model->angle_radians);
                        model->red->y = model->red->y_float;
                    }
                },
                true);
        }
    }

    return 0;
}

static void furious_birds_timer_callback(void* context) {
    furi_assert(context);
    App* app = context;
    furi_thread_flags_set(furi_thread_get_id(app->worker_thread), WorkerEventTick);
}

Red* init_red(AppModel* model) {
    Red* red = malloc(sizeof(Red));
    red->x = RED_START_X;
    red->y = calculate_red_start_y(model);
    red->y_float = red->y;
    return red;
}

Pig* init_pigs() {
    Pig* pigs[PIG_COUNT];
    for(uint8_t i = 0; i < PIG_COUNT; i++) {
        pigs[i] = create_random_pig(i, pigs);
    }
    return pigs[0];
}

App* app_alloc() {
    App* app = malloc(sizeof(App));

    // Gui
    app->gui = furi_record_open(RECORD_GUI);

    // View dispatcher
    app->view_dispatcher = view_dispatcher_alloc();
    view_dispatcher_enable_queue(app->view_dispatcher);
    view_dispatcher_attach_to_gui(app->view_dispatcher, app->gui, ViewDispatcherTypeFullscreen);

    // Views
    app->view = view_alloc();
    view_set_context(app->view, app);
    view_set_draw_callback(app->view, game_draw_callback);
    view_set_input_callback(app->view, game_input_callback);
    view_allocate_model(app->view, ViewModelTypeLocking, sizeof(AppModel));
    with_view_model(
        app->view,
        AppModel * model,
        {
            app->model = model;
            model->angle = ANGLE_START;
            model->angle_radians = degree_to_radian(model->angle);
            model->state = GameStateAiming;
            model->red = init_red(model);
            for(uint8_t i = 0; i < PIG_COUNT; i++) {
                model->pigs[i] = create_random_pig(i, model->pigs);
            }
            model->diff = tan(model->angle_radians);
            model->diff_int = RED_TO_SLINGSHOT_X * model->diff;
        },
        true);

    // view_set_previous_callback(app->view, nupogodi_exit);
    view_dispatcher_add_view(app->view_dispatcher, 0, app->view);
    view_dispatcher_switch_to_view(app->view_dispatcher, 0);

    app->worker_thread =
        furi_thread_alloc_ex("FuriousBirdsWorker", 1024, furious_birds_worker, app);
    furi_thread_start(app->worker_thread);

    app->timer = furi_timer_alloc(furious_birds_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, furi_ms_to_ticks(50));

    return app;
}

void app_free(App* app) {
    furi_assert(app);

    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);

    furi_thread_flags_set(furi_thread_get_id(app->worker_thread), WorkerEventStop);
    furi_thread_join(app->worker_thread);
    furi_thread_free(app->worker_thread);

    // Free animals
    free(app->model->red);
    for(uint8_t i = 0; i < PIG_COUNT; i++) {
        free(app->model->pigs[i]);
    }

    free(app->model);

    // Free views
    view_dispatcher_remove_view(app->view_dispatcher, 0);
    view_free(app->view);
    view_dispatcher_free(app->view_dispatcher);

    // Close gui record
    furi_record_close(RECORD_GUI);
    app->gui = NULL;

    // Free rest
    free(app);
}

int32_t furious_birds_app(void* p) {
    UNUSED(p);
    App* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);
    return 0;
}
